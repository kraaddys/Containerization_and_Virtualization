# Лабораторная работа №6. Взаимодействие контейнеров

## Студент

**Славов Константин, группа I2302**  
**Дата выполнения: _03.04.2025_**

## Цель работы

Данная лабораторная работа призвана научить студента управлять взаимодействием нескольких контейнеров.

## Задание

Создать **PHP-приложение** на базе двух контейнеров: `nginx` и `php-fpm`.

## Ход работы

**1. Создал репозиторий `containers06` и склонировал его к себе на компьютер.**

![image](https://i.imgur.com/GBzjR9N.jpeg)

**2. В директории containers06 создайте директорию mounts/site. В данную директорию перепишите сайт на php, созданный в рамках предмета по php.**

В качестве сайта я взял образец, выполненный по заданию Лабораторной работы №3 по предмету **PHP**.

![image](https://i.imgur.com/R2Lv1s8.jpeg)

**3. Создайте файл .gitignore в корне проекта и добавьте в него строки:**

```sh
# Ignore files and directories
mounts/site/*
```

![image](https://i.imgur.com/kEPcs4j.jpeg)

**4. Создайте в директории containers05 файл nginx/default.conf со следующим содержимым:**

```php
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$ {
        fastcgi_pass backend:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```

Этот блок описывает настройки веб-сервера. Директива `listen 80;` указывает серверу слушать HTTP-порт 80. `server_name _;` означает, что сервер будет обрабатывать все запросы, независимо от имени хоста. `root /var/www/html;` указывает, где расположены файлы сайта внутри контейнера. `index index.php;` задаёт файл, который будет загружаться по умолчанию.
Блок `location /` отвечает за обработку корневого пути и пробует найти файл или папку, иначе перенаправляет запрос на `index.php`. Блок `location ~ \.php$` обрабатывает PHP-файлы: отправляет их на обработку в **PHP-FPM**, указывает путь к исполняемому файлу и включает стандартные параметры **FastCGI**.

## Запуск и тестирование

**1. Создайте сеть internal для контейнеров.**

Для этого я использовал следующую команду:

```sh
docker network create internal
```

![image](https://i.imgur.com/29Nd10m.jpeg)

Эта команда создаёт новую внутреннюю (пользовательскую) сеть с названием **internal**. Такая сеть позволяет контейнерам взаимодействовать друг с другом по имени, не раскрывая доступ извне. Внутри этой сети контейнеры могут "видеть" друг друга и обмениваются данными безопасно.

**2. Создайте контейнер backend со следующими свойствами:**

- На базе образа php:7.4-fpm;
- К контейнеру примонтирована директория mounts/site в /var/www/html;
- Работает в сети internal.

Для этого, я использовал следующие команды:

```sh
docker run -d `
  --name backend `
  --network internal `
  -v ${PWD}\mounts\site:/var/www/html `
  php:7.4-fpm
```

Эта команда создаёт и запускает контейнер с именем **backend** на базе образа `php:7.4-fpm`, который предназначен для обработки **PHP-кода**. Контейнер работает в сети **internal** и получает доступ к локальной папке `mounts/site`, которая монтируется внутрь контейнера в каталог `/var/www/html`, где ожидаются файлы сайта. Контейнер запускается в фоновом режиме.

![image](https://i.imgur.com/fDvKzx2.jpeg)

**3.Создайте контейнер frontend со следующими свойствами:**

- На базе образа nginx:1.23-alpine;
- С примонтированной директорией mounts/site в /var/www/html;
- С примонтированным файлом nginx/default.conf в /etc/nginx/conf.d/default.conf;
- Порт 80 контейнера проброшен на порт 80 хоста;
- Работает в сети internal.

Для этого, я использовал следующие команды:

```sh
docker run -d `
  --name frontend `
  --network internal `
  -v ${PWD}\mounts\site:/var/www/html `
  -v ${PWD}\nginx\default.conf:/etc/nginx/conf.d/default.conf `
  -p 80:80 `
  nginx:1.23-alpine
```

Эта команда запускает контейнер с именем **frontend** на базе образа `nginx:1.23-alpine`. Он также подключается к сети **internal**, чтобы иметь доступ к контейнеру **backend**. В контейнер монтируются две директории: `mounts/site` с файлами сайта и `nginx/default.conf` — файл конфигурации сервера **Nginx**. Порт 80 контейнера пробрасывается на порт 80 хоста, чтобы сайт был доступен по адресу `http://localhost`. Контейнер запускается в фоновом режиме.

![image](https://i.imgur.com/yzTyDdz.jpeg)

**4. Проверьте работу сайта в браузере, перейдя по адресу `http://localhost`**

Для выполнения этого шага, я ввел данный адрес в браузер и получил работающий сайт со всем функционалом, который должен быть:

![image](https://i.imgur.com/kVZ2UD5.jpeg)

## Ответы на вопросы

**1. Каким образом в данном примере контейнеры могут взаимодействовать друг с другом?**

Контейнеры могут взаимодействовать друг с другом через **общую Docker-сеть**. Docker предоставляет механизмы организации виртуальных сетей, которые позволяют контейнерам обмениваться данными и обращаться друг к другу по имени. Если несколько контейнеров подключены к одной и той же сети (например, bridge или пользовательской), они могут взаимодействовать напрямую без проброса портов на хост-машину. Это особенно важно при построении многоуровневых приложений, где, например, один контейнер работает как веб-сервер, другой — как база данных, и между ними должен происходить обмен информацией.

**2. Как видят контейнеры друг друга в рамках одной сети?**

Внутри одной пользовательской сети Docker автоматически настраивает **внутренний DNS-сервер**, который позволяет контейнерам обращаться друг к другу по имени, заданному при запуске с помощью опции `--name`. Это значит, что если один контейнер называется `db`, то другой контейнер в той же сети может просто обратиться к `db`, и Docker **сам определит IP-адрес этого контейнера.** Такой механизм обеспечивает простоту настройки взаимодействия и делает систему более гибкой и устойчивой, так как отпадает необходимость в жёстком прописывании IP-адресов, которые могут изменяться при перезапуске контейнеров.

**3. Почему может потребоваться переопределять конфигурацию nginx?**

Переопределение конфигурации Nginx может быть необходимо в следующих случаях:

- Изменение поведения сервера: Стандартная конфигурация, поставляемая с образом, может быть слишком простой или не подходящей для конкретных задач. Например, она может обслуживать только статические файлы и не поддерживать проксирование, обработку PHP, перенаправления и другие нужные функции.

- Подключение к внешним или внутренним сервисам: Если Nginx используется как прокси-сервер или фронтенд для других приложений (например, PHP, Node.js, API), нужно явно указать, как пересылать запросы дальше.

- Установка кастомных путей, заголовков, безопасности и CORS: Часто необходимо настроить доступ, кэширование, заголовки безопасности, работу с поддоменами или портами, чего нет в стандартной конфигурации.

- Оптимизация и логирование: Для высоконагруженных систем важно настроить лог-файлы, буферы, таймауты и другие параметры, чего не сделать без доступа к конфигурации.

Таким образом, переопределение конфигурации позволяет максимально адаптировать поведение сервера Nginx под требования конкретного проекта.

## Выводы

В ходе выполнения практического задания была развернута простая веб-инфраструктура на основе Docker-контейнеров, включающая веб-сервер (Nginx) и интерпретатор PHP (PHP-FPM). Основной целью было развертывание и настройка взаимодействия между двумя контейнерами, а также обеспечение доступа к сайту с хоста через браузер.

Первым этапом была создана изолированная Docker-сеть с именем `internal`. Это обеспечило безопасное взаимодействие между контейнерами без необходимости открывать лишние порты на внешнюю среду. Благодаря этой сети контейнеры могут "видеть" друг друга и обращаться по имени, что упрощает настройку взаимодействия между компонентами.

Затем был создан контейнер `backend`, основанный на образе `php:7.4-fpm`. Он выполняет роль интерпретатора PHP-кода. Контейнер получил доступ к общей директории с сайтом, которая монтируется в нужную директорию внутри контейнера. Это позволило PHP обрабатывать те же файлы, к которым обращается Nginx.

Далее был настроен контейнер `frontend`, использующий легковесный образ `nginx:1.23-alpine`. Этот контейнер был подключён к той же сети, что и `backend`, и также получил доступ к директории сайта. Основной задачей веб-сервера Nginx стало проксирование запросов к PHP через FastCGI. Для этого была переопределена конфигурация Nginx путём монтирования собственного файла `default.conf`. Этот файл определял, как обрабатывать входящие запросы, где искать файлы сайта и как пересылать `.php`-файлы на обработку в контейнер `backend`.

После запуска обоих контейнеров и проброса порта 80 на хост, сайт стал доступен по адресу `http://localhost`. Проверка в браузере показала корректную работу связки Nginx + PHP-FPM, подтверждая, что инфраструктура была настроена правильно.

Таким образом, в ходе работы были закреплены ключевые навыки работы с Docker: создание пользовательских сетей, запуск и конфигурация контейнеров, монтирование файлов и директорий, настройка взаимодействия между сервисами, а также базовая настройка веб-сервера Nginx. Эти знания являются фундаментом при построении более сложных микросервисных архитектур и развёртывании приложений в контейнеризованной среде.

## Библиография

- [Docker Docs – Networking Overview](https://docs.docker.com/network/) - В официальной документации Docker подробно описаны типы сетей (bridge, host, overlay и т.д.), способы создания пользовательских сетей, взаимодействие контейнеров по имени, настройка DNS внутри Docker-сетей. Это основной источник по теме сетевого взаимодействия между контейнерами.
- [Docker: Создание сети с флагом --internal](https://docs.docker.com/reference/cli/docker/network/create/) - Официальная документация Docker, объясняющая использование команды docker network create с различными опциями, включая флаг --internal.
- [Обзор сетей в Docker](https://docs.docker.com/engine/network/) - Раздел официальной документации Docker, посвященный различным типам сетей, их созданию и использованию.
- [Docker Docs – Use volumes](https://docs.docker.com/storage/volumes/) - Официальное руководство по работе с томами (volumes) и монтированием локальных директорий в контейнеры. Рассматриваются типы томов, команды для их подключения, а также примеры использования.
- [Docker Hub – php:7.4-fpm](https://hub.docker.com/_/php) - Страница официального образа PHP. Здесь указаны теги (версии), переменные среды, способы подключения и примеры использования PHP-FPM. Полезно для понимания, как использовать этот образ для обработки PHP-кода в контейнерах.
- [Docker Hub – nginx](https://hub.docker.com/_/nginx) - Описание официального образа Nginx. Объясняется, как настраивать конфигурационные файлы, подключать тома, работать с пользовательскими конфигами и пробрасывать порты. Также указаны типичные сценарии использования.
- [Nginx Docs – Beginner’s Guide](https://nginx.org/en/docs/beginners_guide.html) - Руководство для начинающих по работе с Nginx. Объясняет основы конфигурации, настройку виртуальных хостов, маршрутизацию запросов, а также взаимодействие с FastCGI (например, PHP-FPM).
- [PHP Manual – PHP-FPM (FastCGI Process Manager)](https://www.php.net/manual/en/install.fpm.php) - Официальная документация PHP по установке и работе с PHP-FPM. Описывает его архитектуру, настройку пула процессов, взаимодействие с веб-серверами через FastCGI.
